package entity;

public transformation EntityToSQL {
  main : 
  	   CompilationUnit(decls)
  	-> CompilationUnit(all-decls)
  where java-decls := <map(?ModelDec(_,_) < entity-to-sql + id)> decls
      ; new-imports := [TypeImportDec(Id("java.sql.*")), TypeImportDec(Id("sql.Commands"))]
      ; all-decls := <insert-java-imports> (new-imports, java-decls)
  
  insert-java-imports :
       (imports, [p@PackageDec(_,_)|decls]) -> <concat> [[p], imports, decls]
  inser-java-imports :
       (imports, decls) -> <concat> [imports, decls]
  
  entity-to-sql :
       ModelDec(ModelDecHead(mods, Id(name), Id("Entity")), ModelBody(body))
    -> ClassDec(ClassDecHead(mods, Id(name), None, None, None), ClassBody(decls))
  where init := <make-sql-init(|name)> body
      ; constr := <make-java-constr(|name)> body
      ; accessors := <mapconcat(\t -> [<make-java-getter(|name)> t, <make-java-setter(|name, body)> t]\)> body
      ; decls := <concat> [init, [constr], accessors]

  make-sql-init(|table-name) :
       fields
    -> [FieldDec([Private(), Static()],
                 ClassOrInterfaceType(TypeName(Id("Connection")), None()),
                 [ VarDec(Id("connection"),
                     Invoke(Method(MethodName(AmbName(Id("Commands")), Id("connect"))),
                            [Lit(String([Chars("jdbc:mysql://localhost:3306/entities")]))]))])
       ,FieldDec([Private(), Static()],
                 ClassOrInterfaceType(TypeName(Id("Statement")), None()),
                 [VarDec(Id("stmt"),
                    Invoke(Method(MethodName(AmbName(Id("Commands")), Id("createStatement"))),
                           [ExprName(Id("connection"))]))])
       ,StaticInit(Block([ExprStm(
          Invoke(Method(MethodName(AmbName(Id("Commands")), Id("createTable"))),
                 [ExprName(Id("stmt"))
                 , Lit(String([Chars(table-name)]))
                 | sql-cols]))]))
       ,FieldDec([Private()], Long(), [VarDec(Id("key"))])
       ]
  where sql-cols := <map(\Tuple([name, type]) -> <conc-strings>(name, " ", <to-sql-type> type)\; !Lit(String([Chars(<id>)])))> fields


  make-java-getter(|table-name) :
       Tuple([name, type])
    -> MethodDec(MethodDecHead([Public], None, java-type, Id(get-name),[],None), Block([Return(Some(select-exp))]))
  where java-type := <to-java-type> type
      ; get-name := <concat-strings> ["get", <first-upper> name]
      ; select-exp :=
          Invoke(Method(MethodName(AmbName(Id("Commands")), Id(<sql-selector-for-type> type))),
                 [ ExprName(Id("stmt"))
                 , Lit(String([Chars(table-name)]))
                 , ExprName(Id("key"))
                 , Lit(String([Chars(name)]))
                 ])

  make-java-setter(|class-name, fields) :
       Tuple([name, type])
    -> MethodDec(MethodDecHead([Public], None, this-class-type, Id(set-name),[java-param],None),Block([ExprStm(update-exp), Return(Some(This))]))
  where this-class-type := <to-java-type> class-name
      ; java-type := <to-java-type> type
      ; set-name := <concat-strings> ["set", <first-upper> name]
      ; java-param := <make-java-param> Tuple([name, type])
      ; update-exp := 
          Invoke(Method(MethodName(AmbName(Id("Commands")), Id("update"))),
                [ ExprName(Id("stmt"))
                , Lit(String([Chars(class-name)]))
                , ExprName(Id("key"))
                , Lit(String([Chars(name)]))
                , ExprName(Id(name))
                ])
  
  make-java-new-expr(|class-name) :
       fields
    -> NewInstance(None,ClassOrInterfaceType(TypeName(Id(class-name)),None), args, None)
  where args := <map(?Tuple([<id>,_]); make-java-var-ref)> fields 

  
  make-java-var-ref :
       name
    -> ExprName(Id(name))

  make-java-constr(|table-name) :
       fields
    -> ConstrDec(
         ConstrDecHead([Public], None, Id(table-name), java-params, None),
         ConstrBody(None, [
         	ExprStm(Assign(ExprName(Id("key")),
         	  Invoke(Method(MethodName(AmbName(Id("Commands")), Id("insertInto"))),
         	          [ ExprName(Id("stmt"))
                      , Lit(String([Chars(table-name)]))
                      , Lit(String([Chars(cols-concated)]))
                      | cols-refs
                      ]
                    )
                  )
                )]))
  where java-params := <map(make-java-param)> fields
      ; cols := <map(?Tuple([<id>, _]))> fields
      ; cols-refs := <map(!ExprName(Id(<id>)))> cols
      ; cols-concated := <intersperse(|", "); concat-strings> cols
  
  
  make-java-param :
       Tuple([name1, type1])
    -> Param([], <to-java-type> type1, Id(name1))
 
 
  make-java-init-stmt :
       Tuple([name, type])
    -> ExprStm(Assign(Field(This, Id(name)), ExprName(Id(name))))
  
  to-java-type : "int" -> Int()
  to-java-type : "Integer" -> Int()
  to-java-type : type -> ClassOrInterfaceType(TypeName(Id(type)),None)

  to-sql-type : "int" -> "int"
  to-sql-type : "Integer" -> "int"
  to-sql-type : "String" -> "varchar(64)"

  sql-selector-for-type : "int" -> "selectIntCol"
  sql-selector-for-type : "Integer" -> "selectIntCol"
  sql-selector-for-type : "String" -> "selectStringCol"
  
  first-upper = string-as-chars([to-upper|id])

  intersperse(|s) : [] -> []
  intersperse(|s) : [x] -> [x]
  intersperse(|s) : [x|y] -> [x,s| <intersperse(|s)> y]

}
