module typing.check.TypeChecker

import typing.check.Module
import typing.check.Context

import org.sugarj.languages.Fomega
import org.sugarj.languages.SugarFomega

import typing.check.MetaExplode

rules
  constraint-error: FomegaBody(defs) -> result
    where <signatureOf> (CtxEmpty(),defs) => (sig,errors)
        ; if !errors; ?[] then fail else !errors end => result

desugarings
  generate-type-context

rules
  generate-type-context :
    fb@FomegaBody(defs) -> 
    [ Locked(fb)
    , <make-fomega-sugar> defs
//    , <make-fomega-editor> defs
    ]
  
  make-fomega-sugar = 
    !SugarBody([transformation-elem(Rules(<debug(!"defs:");generate-type-context-rules;debug(!"generated:")> (CtxEmpty(),<id>)))])
  
  generate-type-context-rules :
    (_,[]) -> []
  generate-type-context-rules : 
    (ctx,[TypeDef(None(),X,T) | defs]) -> <generate-type-context-rules> (ctx,defs)
  generate-type-context-rules : 
    (ctx,[TypeDef(Some(Public()),X,T) | defs]) -> 
    [RDefNoArgs("imported-type-context-tyvar", RuleNoCond(NoAnnoList(Str(X)), <trm-explode> K)) | rulez]
    where <kindOf> (ctx,T) => (K,[])
        ; if !K; ?KiUnknown() then !T else <norm> (ctx,T) end => T'
        ; <generate-type-context-rules> (CtxBindTVarDef(ctx,X,K,T'),defs) => rulez
  generate-type-context-rules : 
    (ctx,[ValDef(None(),x,e) | defs]) -> <generate-type-context-rules> (ctx,defs)
  generate-type-context-rules : 
    (ctx,[ValDef(Some(Public()),x,e) | defs]) -> 
    [RDefNoArgs("imported-type-context-var", RuleNoCond(NoAnnoList(Str(x)), <trm-explode> T)) | rulez]
    where <typeOf> (ctx,e) => (T,[])
        ; <generate-type-context-rules> (CtxBindVar(ctx,x,T),defs) => rulez

