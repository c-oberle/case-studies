module typing.check.Expr

//module typing/check/Expr

import typing.check.Context
import typing.check.Type
import typing.check.TypeOperations

// imports typing/check/Context
//        typing/check/Type
//        typing/check/TypeOperations

import org.sugarj.languages.Fomega

//imports org/sugarj/languages/Fomega

rules

  // *** Case expression ***
  //
  // Note: the rules for case expressions are inefficient since they
  // calculate the type of the scrutinee repeatedly -- but they are
  // simple, though, and do not require an additional judgment for
  // branches.
  // This case also rule does not check if we have duplicate labels in
  // branches.
  //

  typeOf:
    (ctx,Case(e1,[Branch(x,y,e2)])) -> (T2,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqVariant> T1' => (decls,msgs2)
        ; <labType> (x,decls) => (S,msgs3)
        ; <typeOf> (CtxBindVar(ctx,y,S),e2) => (T2,msgs4)

  typeOf:
    (ctx,Case(e1,[Branch(x1,x2,e2),Branch(y1,y2,e3)|brs])) ->
    (R,<conc> (msgs1,msgs2,msgs3,msgs4,msgs5))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqVariant> T1' => (decls,msgs2)
        ; <labType> (x1,decls) => (S,msgs3)
        ; <typeOf> (CtxBindVar(ctx,x2,S),e2) => (T2,msgs4)
        ; <typeOf> (ctx,Case(e1,[Branch(y1,y2,e3)|brs])) => (R,msgs4)
        ; <norm> (ctx,T2) => T2'
        ; <norm> (ctx,R) => R'
        ; <typeEq> (T2',R') => msgs5

  // *** Conditional ***
  //

  typeOf:
    (ctx,Cond(e1,e2,e3)) ->
    (T2',<conc> (msgs1,msgs2,msgs3,msgs4,msgs5))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <typeOf> (ctx,e2) => (T2,msgs2)
        ; <typeOf> (ctx,e3) => (T3,msgs3)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqBool> T1' => msgs4
        ; <norm> (ctx,T2) => T2'
        ; <norm> (ctx,T3) => T3'
        ; <typeEq> (T2',T3') => msgs5

  // *** Polymorphic function ***
  //

  typeOf:
    (ctx,TAbs(X,K1,e2)) -> (TyForall(X,K1,T2),msgs1)
    where <typeOf> (CtxBindTVar(ctx,X,K1),e2) => (T2,msgs1)

  // *** Abstraction ***
  //

  typeOf:
    (ctx,Abs(x,T1,e2)) -> (TyArrow(T1,T2),<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (CtxBindVar(ctx,x,T1),e2) => (T2,msgs1)
        ; <kindOf> (ctx,T1) => (K1,msgs2)
        ; <kindEqStar> K1 => msgs3

  // *** Ascription ***
  //

  typeOf:
    (ctx,Ascription(e,T)) -> (T,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e) => (S,msgs1)
        ; <kindOf> (ctx,T) => (K,msgs2)
        ; <kindEqStar> K => msgs3
        ; <norm> (ctx,S) => S'
        ; <norm> (ctx,T) => T'
        ; <typeEq> (T',S') => msgs4

  // *** Unfold ***
  //

  typeOf:
    (ctx,Unfold(T,e)) ->
    (<subst> (X,T',T1),<conc> (msgs1,msgs2,msgs3,msgs4,msgs5,msgs6))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <typeOf> (ctx,e) => (S,msgs3)
        ; <norm> (ctx,T) => T'
        ; <norm> (ctx,S) => S'
        ; <typeEqMu> T' => (X,T1,msgs4)
        ; <typeEqMu> S' => (Y,S1,msgs5)
        ; <fresh> [T',S'] => Z
        ; <subst> (X,TyVar(Z),T1) => T1'
        ; <subst> (Y,TyVar(Z),S1) => S1'
        ; <typeEq> (T1',S1') => msgs6

  // *** Fold ***
  //

  typeOf:
    (ctx,Fold(T,e)) ->
    (T,<conc> (msgs1,msgs2,msgs3))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <norm> (ctx,T) => T'
        ; <typeEqMu> T' => (X,T1,msgs3)
        ; <typeOf> (ctx,e) => S
        ; <typeEq> (S, <subst> (X,TyMu(X,T1),T1)) => msgs4

  // *** TApp ***
  //

  typeOf:
    (ctx,TApp(e1,T2)) -> (<subst> (X,T2,T12),<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqForall> T1' => (X,K11,T12,msgs2)
        ; <kindOf> (ctx,T2) => (K2,msgs3)
        ; <kindEq> (K11,K2) => msgs4

  // *** App ***
  //

  typeOf:
    (ctx,App(e1,e2)) -> (T12,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <typeOf> (ctx,e2) => (T2,msgs2)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqArrow> T1' => (T11,T12,msgs3)
        ; <norm> (ctx,T2) => T2'
        ; <typeEq> (T11,T2') => msgs4

  // *** SelectRcd ***
  //

  typeOf:
    (ctx,SelectRcd(e,x)) -> (S,<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (ctx,e) => (T,msgs1)
        ; <norm> (ctx,T) => T'
        ; <typeEqRecord> T' => (decls,msgs2)
        ; <labType> (x,decls) => (S,msgs3)

  // *** Primitive types ***
  typeOf: (ctx,String(str)) -> (TyString(),[])
  typeOf: (ctx,Nat(n)) -> (TyNat(),[])
  typeOf: (ctx,False()) -> (TyBool(),[])
  typeOf: (ctx,True()) -> (TyBool(),[])

  // *** Variant ***
  //

  typeOf:
    (ctx,Variant(Field(x,e),T)) -> (T,<conc> (msgs1,msgs2,msgs3,msgs4,msgs5,msgs6))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <typeOf> e => (S,msgs3)
        ; <norm> S => S'
        ; <norm> T => T'
        ; <typeEqVariant> T' => (decls,msgs4)
        ; <labType> (x,decls) => (U,msgs5)
        ; <typeEq> (S',U) => msgs6

  // *** Record ***
  //

  typeOf:
    (ctx,Record([])) -> (TyRecord([]),[])

  typeOf:
    (ctx,Record([Field(x,e)|flds])) ->
    (Record([Field(x,T)|decls]),<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (ctx,e) => T
        ; <typeOf> (ctx,Record(flds)) => (S,msgs1)
        ; <norm> (ctx,S) => S'
        ; <typeEqRecord> S' => (decls,msgs2)
        ; errorUnless(<not(elem)> (x,<lab> flds)
                     | <concat-strings> ["duplicate label ",x]) => msgs3

  // *** Var ***
  typeOf:
    (CtxEmpty(),Var(x)) -> (TyUnknown(),["undefined identifier ",x])
  typeOf:
    (CtxBindQVar(ctx,qy,T),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindQTVarDef(ctx,qY,K,T),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindTVar(ctx,Y,K),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindTVarDef(ctx,Y,K,T),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindVar(ctx,x,T),Var(x)) -> (T,[])
  typeOf:
    (CtxBindVar(ctx,y,T),Var(x)) -> <typeOf> (ctx,Var(x))
    where <not(equal)> (y,x)

  // *** QVar ***
  typeOf:
    (CtxEmpty(),QVar(qx)) -> (TyUnknown(),["undefined identifier ",qx])
  typeOf:
    (CtxBindVar(ctx,y,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindQTVarDef(ctx,qY,K,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindTVar(ctx,Y,K),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindTVarDef(ctx,Y,K,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindQVar(ctx,qx,T),QVar(qx)) -> (T,[])
  typeOf:
    (CtxBindQVar(ctx,qy,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
    where <not(equal)> (qy,qx)


