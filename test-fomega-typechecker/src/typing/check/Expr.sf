module typing.check.Expr

import typing.check.Context
import typing.check.Type
import typing.check.TypeOperations

import org.sugarj.languages.Fomega

rules

  // *** Case expression ***
  //
  // Note: the rules for case expressions are inefficient since they
  // calculate the type of the scrutinee repeatedly -- but they are
  // simple, though, and do not require an additional judgment for
  // branches.
  // This case also rule does not check if we have duplicate labels in
  // branches.
  //
  // Γ ⊢ e1 : T1 Γ ⊢ T1 ⇓ <decls> x:S ∈ decls Γ,y:S ⊢ e2 : T2
  // ---------------------------------------------------------------
  // Γ ⊢ case e1 of <x=y> ⇒ e2 : T2
  typeOf:
    (ctx,Case(e1,[Branch(x,y,e2)])) -> (T2,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqVariant> T1' => (decls,msgs2)
        ; <labType> (x,decls) => (S,msgs3)
        ; <typeOf> (CtxBindVar(ctx,y,S),e2) => (T2,msgs4)
  // Γ ⊢ e1 : T1 Γ ⊢ T1 ⇓ <decls> x:S ∈ decls Γ,y:S ⊢ e2 : T2
  // Γ ⊢ case e1 of brs : R Γ ⊢ T2 ⇓ U Γ ⊢ R ⇓ U
  // ---------------------------------------------------------------
  // Γ ⊢ case e1 <x=y> ⇒ e2; brs : U
  typeOf:
    (ctx,Case(e1,[Branch(x1,x2,e2),Branch(y1,y2,e3)|brs])) ->
    (R,<conc> (msgs1,msgs2,msgs3,msgs4,msgs5))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqVariant> T1' => (decls,msgs2)
        ; <labType> (x1,decls) => (S,msgs3)
        ; <typeOf> (CtxBindVar(ctx,x2,S),e2) => (T2,msgs4)
        ; <typeOf> (ctx,Case(e1,[Branch(y1,y2,e3)|brs])) => (R,msgs4)
        ; <norm> (ctx,T2) => T2'
        ; <norm> (ctx,R) => R'
        ; <typeEq> (T2',R') => msgs5

  // *** Conditional ***
  //
  // Γ ⊢ e1 : T1 Γ ⊢ e2 : T2 Γ ⊢ e3 : T3
  // Γ ⊢ T1 ⇓ Bool Γ ⊢ T2 ⇓ U Γ ⊢ T3 ⇓ U
  // ----------------------------------------
  // Γ ⊢ if e1 then e2 else e3 : U
  typeOf:
    (ctx,Cond(e1,e2,e3)) ->
    (T2',<conc> (msgs1,msgs2,msgs3,msgs4,msgs5))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <typeOf> (ctx,e2) => (T2,msgs2)
        ; <typeOf> (ctx,e3) => (T3,msgs3)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqBool> T1' => msgs4
        ; <norm> (ctx,T2) => T2'
        ; <norm> (ctx,T3) => T3'
        ; <typeEq> (T2',T3') => msgs5

  // *** Polymorphic function ***
  //
  // Γ,X::K1 ⊢ e2 : T2
  // ----------------------------
  // Γ ⊢ \X::K1. e2 : ∀ X::K1. T2
  typeOf:
    (ctx,TAbs(X,K1,e2)) -> (TyForall(X,K1,T2),msgs1)
    where <typeOf> (CtxBindTVar(ctx,X,K1),e2) => (T2,msgs1)

  // *** Abstraction ***
  //
  // Γ,x:T1 ⊢ e2 : T2 Γ ⊢ T1 :: *
  // ------------------------------
  // Γ ⊢ \x::T1. e2 : T1 → T2
  typeOf:
    (ctx,Abs(x,T1,e2)) -> (TyArrow(T1,T2),<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (CtxBindVar(ctx,x,T1),e2) => (T2,msgs1)
        ; <kindOf> (ctx,T1) => (K1,msgs2)
        ; <kindEqStar> K1 => msgs3

  // *** Ascription ***
  //
  // Γ ⊢ e : S Γ ⊢ T :: * Γ ⊢ S ⇓ U Γ ⊢ T ⇓ U
  // -----------------------------------------------
  // Γ ⊢ e as T : T
  typeOf:
    (ctx,Ascription(e,T)) -> (T,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e) => (S,msgs1)
        ; <kindOf> (ctx,T) => (K,msgs2)
        ; <kindEqStar> K => msgs3
        ; <norm> (ctx,S) => S'
        ; <norm> (ctx,T) => T'
        ; <typeEq> (T',S') => msgs4

  // *** Unfold ***
  //
  // Γ ⊢ e : S Γ ⊢ T :: * Γ ⊢ S ⇓ U Γ ⊢ T ⇓ U
  // -----------------------------------------------
  // Γ ⊢ e as T : T
  typeOf:
    (ctx,Unfold(T,e)) ->
    (<subst> (X,T',T1),<conc> (msgs1,msgs2,msgs3,msgs4,msgs5,msgs6))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <typeOf> (ctx,e) => (S,msgs3)
        ; <norm> (ctx,T) => T'
        ; <norm> (ctx,S) => S'
        ; <typeEqMu> T' => (X,T1,msgs4)
        ; <typeEqMu> S' => (Y,S1,msgs5)
        ; <fresh> [T',S'] => Z
        ; <subst> (X,TyVar(Z),T1) => T1'
        ; <subst> (Y,TyVar(Z),S1) => S1'
        ; <typeEq> (T1',S1') => msgs6

  // *** Fold ***
  //
  // Γ ⊢ T :: * Γ ⊢ T ⇓ μX.U Γ ⊢ e : [X↦μX.U]U
  // ----------------------------------------------
  // Γ ⊢ fold [T] e : T
  typeOf:
    (ctx,Fold(T,e)) ->
    (T,<conc> (msgs1,msgs2,msgs3))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <norm> (ctx,T) => T'
        ; <typeEqMu> T' => (X,T1,msgs3)
        ; <typeOf> (ctx,e) => S
        ; <typeEq> (S, <subst> (X,TyMu(X,T1),T1)) => msgs4

  // *** TApp ***
  //
  // Γ ⊢ e1 : T1 Γ ⊢ T1 ⇓ ∀X::K11.T12 Γ ⊢ T2 :: K11
  // ---------------------------------------------------
  // Γ ⊢ e1 [T2] : [X↦T2]T12
  typeOf:
    (ctx,TApp(e1,T2)) -> (<subst> (X,T2,T12),<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqForall> T1' => (X,K11,T12,msgs2)
        ; <kindOf> (ctx,T2) => (K2,msgs3)
        ; <kindEq> (K11,K2) => msgs4

  // *** App ***
  //
  // Γ ⊢ e1 : T1 Γ ⊢ e2: T2 Γ ⊢ T1 ⇓ T11 → T12 Γ ⊢ T2 ⇓ T11
  // -------------------------------------------------------------
  // Γ ⊢ e1 e2 : T12
  typeOf:
    (ctx,App(e1,e2)) -> (T12,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <typeOf> (ctx,e2) => (T2,msgs2)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqArrow> T1' => (T11,T12,msgs3)
        ; <norm> (ctx,T2) => T2'
        ; <typeEq> (T11,T2') => msgs4

  // *** SelectRcd ***
  //
  // Γ ⊢ e : T Γ ⊢ T ⇓ {decls} x:S ∈ decls
  // ------------------------------------------
  // Γ ⊢ e!x : S
  typeOf:
    (ctx,SelectRcd(e,x)) -> (S,<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (ctx,e) => (T,msgs1)
        ; <norm> (ctx,T) => T'
        ; <typeEqRecord> T' => (decls,msgs2)
        ; <labType> (x,decls) => (S,msgs3)

  // *** Primitive types ***
  typeOf: (ctx,String(str)) -> (TyString(),[])
  typeOf: (ctx,Nat(n)) -> (TyNat(),[])
  typeOf: (ctx,False()) -> (TyBool(),[])
  typeOf: (ctx,True()) -> (TyBool(),[])

  // *** Variant ***
  //
  // Γ ⊢ T :: * Γ ⊢ e : S Γ ⊢ S ⇓ U Γ ⊢ T ⇓ <decls> x:U ∈ decls
  // -------------------------------------------------------------------
  // Γ ⊢ <x=e> as T : T
  typeOf:
    (ctx,Variant(Field(x,e),T)) -> (T,<conc> (msgs1,msgs2,msgs3,msgs4,msgs5,msgs6))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <typeOf> e => (S,msgs3)
        ; <norm> S => S'
        ; <norm> T => T'
        ; <typeEqVariant> T' => (decls,msgs4)
        ; <labType> (x,decls) => (U,msgs5)
        ; <typeEq> (S',U) => msgs6

  // *** Record ***
  //
  // -----------
  // Γ ⊢ {} : {}
  typeOf:
    (ctx,Record([])) -> (TyRecord([]),[])
  // Γ ⊢ e : T Γ ⊢ {flds} : S Γ ⊢ S ⇓ {decls} x ∉ lab(decls)
  // --------------------------------------------------------------
  // Γ ⊢ {x=e,flds} : {x:T,decls}
  typeOf:
    (ctx,Record([Field(x,e)|flds])) ->
    (Record([Field(x,T)|decls]),<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (ctx,e) => T
        ; <typeOf> (ctx,Record(flds)) => (S,msgs1)
        ; <norm> (ctx,S) => S'
        ; <typeEqRecord> S' => (decls,msgs2)
        ; errorUnless(<not(elem)> (x,<lab> flds)
                     | <concat-strings> ["duplicate label ",x]) => msgs3

  // *** Var ***
  typeOf:
    (CtxEmpty(),Var(x)) -> (TyUnknown(),["undefined identifier ",x])
  typeOf:
    (CtxBindQVar(ctx,qy,T),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindQTVarDef(ctx,qY,K,T),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindTVar(ctx,Y,K),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindTVarDef(ctx,Y,K,T),Var(x)) -> <typeOf> (ctx,Var(x))
  typeOf:
    (CtxBindVar(ctx,x,T),Var(x)) -> (T,[])
  typeOf:
    (CtxBindVar(ctx,y,T),Var(x)) -> <typeOf> (ctx,Var(x))
    where <not(equal)> (y,x)

  // *** QVar ***
  typeOf:
    (CtxEmpty(),QVar(qx)) -> (TyUnknown(),["undefined identifier ",qx])
  typeOf:
    (CtxBindVar(ctx,y,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindQTVarDef(ctx,qY,K,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindTVar(ctx,Y,K),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindTVarDef(ctx,Y,K,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
  typeOf:
    (CtxBindQVar(ctx,qx,T),QVar(qx)) -> (T,[])
  typeOf:
    (CtxBindQVar(ctx,qy,T),QVar(qx)) -> <typeOf> (ctx,QVar(qx))
    where <not(equal)> (qy,qx)

// *** Notes ***
//
// Judgments:
// * x ∉ sel(flds)
// * x:S ∈ decls
// * qx ≠ qy
// * x ≠ y
// * Γ ⊢ e : T
// * Γ ⊢ T :: K
// * Γ ⊢ T ⇓ S
// * error(<msg>)
//
// Structural equality of types modulo α-conversion, record/variant permutation,
// and with TyUnknown equal to any type.
//
// Conditional decomposition types, i.e. Nat, Bool, String, mu X.T,
// forall X::K.T, T->S, {x:T,...,y:S}, <x:T,...,y:S>.