module typing.rules.Desugaring

import org.sugarj.languages.Fomega

import typing.rules.Syntax
import typing.check.Type
import typing.check.TypeOperations

import concretesyntax.Stratego

rules
  desugar-type-rule :
    TypeRule(premises, RuleName(sep, optional-name), conclusion) ->
      transformation-elem(<translate-type-rule> (optional-name, premises, conclusion))

rules
    // TypeRule(premises, RuleName(x, Some(Var(name))), conclusion) ->
    //   [RDefNoArgs("foo", RuleNoCond(NoAnnoList(Str(name)), <trm-explode> (premises, conclusion)))]

  translate-type-rule :
    (Some(Var(name)), premises, TypingJudgment(C, e, T)) ->
    stratego-decl
    |[ rules
         typeOf :
           (term~tC, term~te) -> (term~tT, [])
           where strategy~premises-implementation
    ]|
    where <trm-explode> C => tC
        ; <trm-explode> e => te
        ; <trm-explode> T => tT
        ; <premises-to-list> premises => premises-list
        ; <translate-premises> (0, premises-list) => (n, premises-implementation)

  premises-to-list :
    NoPremises -> []
  premises-to-list :
    PremiseList(premises) -> <premises-to-list> premises
  premises-to-list :
    PremiseCons(judgment, premises) ->
      [judgment | <premises-to-list> premises]
  premises-to-list :
    judgment -> [judgment]
    where if (!judgment; ?PremiseCons(_,_)) then fail else id end

  translate-premises :
    (n, []) -> (n, |[ id ]|)

  translate-premises :
    (n, [judgment | judgments]) ->
      (n2, |[ strategy~judgment-implementation ; strategy~judgments-implementation ]|)
    where <translate-judgment> (n, judgment)   => (n1, judgment-implementation)
        ; <translate-premises> (n1, judgments) => (n2, judgments-implementation)

  translate-judgment :
    (n, TypingJudgment(C, e, T)) -> (n, |[ <typeOf> (term~tC, term~te) => term~tT ]|)
    where <trm-explode> C => tC
        ; <trm-explode> e => te
        ; <trm-explode> T => tT

  translate-judgment :
    (n, KindingJudgment(C, T, K)) -> (n, |[ <kindOf> (term~tC, term~tT) => term~tK ]|)
    where <trm-explode> C => tC
        ; <trm-explode> T => tT
        ; <trm-explode> K => tK

  translate-judgment :
    (n, NormalizationJudgment(C, T, T')) ->
      (n, |[ <norm> (term~tC, term~tT) => term~tT' ]|)
    where <trm-explode> C  => tC
        ; <trm-explode> T  => tT
        ; <trm-explode> T' => tT'

      // |[ rules foo: 1 -> [1,2,3] ]|




    //TypeRule(premises,RuleName(x,Some(Var(name))),conclusion) ->
      // [RDefNoArgs("foo", RuleNoCond(NoAnnoList(Str(name)), <trm-explode> (premises,conclusion)))]

  // desugar-type-rule0:
  //   any -> ValDef(None(),"foo",1)


desugarings
  desugar-type-rule

rules
  TrmFromTerm = 
    ?Metavar(<MetaExplode>)