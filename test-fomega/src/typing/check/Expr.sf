module typing.check.Expr

import typing.check.Context
import typing.check.Type

import org.sugar.languages.Fomega

signature
  constructors
    TyUnknown: FomegaType

rules
  labType: (x,[]) -> (TyUnknown, ["undefined label ",x])
  labType: (x,[TyDecl(x,T)|decls]) -> (T,[])
  labType: (x,[TyDecl(y,T)|decls]) -> <labType> (x,decls)
           where <not(equal)> (x,y)

  sel = fail // TODO

  norm = fail // TODO
  typeEq = fail // TODO
  subst = fail // TODO

  typeEqVariant: TyVariant(decls) -> (decls,[])
  typeEqVariant:
    T -> ([],[<concat-string> ["type mismatch, expected variant type but found"
                              ,<write-to-string> T]])
    where if (!T; ?TyVariant(_)) then fail else id end

  // *** Case expression ***
  //
  // Note: the rules for case expressions are inefficient since they
  // calculate the type of the scrutinee repeatedly -- but they are
  // simple, though, and do not require an additional judgment for
  // branches.
  // This case also rule does not check if we have duplicate labels in
  // branches.
  //
  // Γ ⊢ e1 : T1   Γ ⊢ T1 ⇓ <decls>   x:S ∈ decls   Γ,y:S ⊢ e2 : T2
  // ---------------------------------------------------------------
  // Γ ⊢ case e1 of <x=y> ⇒ e2 : T2
  typeOf:
    (ctx,Case(e1,[Branch(x,y,e2)])) -> (T2,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqVariant> T1' => (decls,msgs2)
        ; <labType> (x,decls) => (S,msgs3)
        ; <typeOf> (CtxBindVar(ctx,y,S),e2) => (T2,msgs4)
  // Γ ⊢ e1 : T1   Γ ⊢ T1 ⇓ <decls>   x:S ∈ decls   Γ,y:S ⊢ e2 : T2
  // Γ ⊢ case e1 of brs : R          Γ ⊢ T2 ⇓ U           Γ ⊢ R ⇓ U
  // ---------------------------------------------------------------
  // Γ ⊢ case e1 <x=y> ⇒ e2; brs : U
  typeOf:
    (ctx,Case(e1,[Branch(x1,x2,e2),Branch(y1,y2,e3)|brs])) ->
    (U,<conc> (msgs1,msgs2,msgs3,msgs4,msg5))
    where <typeof> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqVariant> T1' => (decls,msgs2)
        ; <labType> (x1,decls) => (S,msgs3)
        ; <typeOf> (CtxBindVar(ctx,x2,S),e2) => (T2,msgs4)
        ; <typeOf> (ctx,Case(e1,[Branch(y1,y2,e3)|brs])) => (R,msgs4)
        ; <norm> (ctx,T2) => T2'
        ; <norm> (ctx,R) => R'
        ; <typeEq> (T2',R2') => msgs5

  // *** Conditional ***
  //
  // Γ ⊢ e1 : T1   Γ ⊢ e2 : T2   Γ ⊢ e3 : T3
  // Γ ⊢ T1 ⇓ Bool   Γ ⊢ T2 ⇓ U   Γ ⊢ T3 ⇓ U
  // ----------------------------------------
  // Γ ⊢ if e1 then e2 else e3 : U
  typeOf:
    (ctx,Cond(e1,e2,e3)) ->
    (T2',<conc> (msgs1,msgs2,msgs3,msgs4,msgs5))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <typeOf> (ctx,e2) => (T2,msgs2)
        ; <typeOf> (ctx,e3) => (T3,msgs3)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqBool> T1' => msgs4
        ; <norm> (ctx,T2) => T2'
        ; <norm> (ctx,T3) => T3'
        ; <typeEq> (T2',T3') => msgs5

  // *** Polymorphic function ***
  //
  // Γ,X::K1 ⊢ e2 : T2
  // ----------------------------
  // Γ ⊢ \X::K1. e2 : ∀ X::K1. T2
  typeOf:
    (ctx,TAbs(X,K1,e2)) -> (TyForall(X,K1,T2),msgs1)
    where <typeof> (CtxBindTVar(ctx,X,K1),e2) => (T2,msgs1)

  // *** Abstraction ***
  //
  // Γ,x:T1 ⊢ e2 : T2   Γ ⊢ T1 :: *
  // ------------------------------
  // Γ ⊢ \x::T1. e2 : T1 → T2
  typeOf:
    (ctx,Abs(x,T1,e2)) -> (TyFun(T1,T2),<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (CtxBindVar(ctx,x,T1),e2) => (T2,msgs1)
        ; <kindOf> (ctx,T1) => (K1,msgs2)
        ; kindEqStar K1 => msgs3

  // *** Ascription ***
  //
  // Γ ⊢ e : S   Γ ⊢ T :: *   Γ ⊢ S ⇓ U   Γ ⊢ T ⇓ U
  // -----------------------------------------------
  // Γ ⊢ e as T : T
  typeOf:
    (ctx,Ascription(e,T)) -> (T,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e) => (S,msgs1)
        ; <kindOf> (ctx,T) => (K,msgs2)
        ; <kindEqStar> K => msgs3
        ; <norm> (ctx,S) => S'
        ; <norm> (cyx,T) => T'
        ; <typeEq> (T',S') => msgs4

  // *** Unfold ***
  //
  // Γ ⊢ T :: *   Γ ⊢ e : S   Γ ⊢ S ⇓ μX.U   Γ ⊢ U ⇓ μX.U
  // -----------------------------------------------------
  // Γ ⊢ unfold [T] e : [X↦μX.U]U
  typeOf:
    (ctx,Unfold(T,e)) ->
    (<subst> (X,T',T1),<conc> (msgs1,msgs2,msgs3,msgs4,msgs5,msgs6)
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <typeOf> (ctx,e) => (S,msgs3)
        ; <norm> (ctx,T) => T'
        ; <norm> (ctx,S) => S'
        ; <typeEqMu> T' => (X,T1,msgs4)
        ; <typeEqMu> S' => (Y,S1,msgs5)
        ; <fresh> [T',S'] => Z
        ; <subst> (X,TyVar(Z),T1) => T1'
        ; <subst> (Y,TyVar(Z),S1) => S1'
        ; <typeEq> (T1',S1') => msgs6

  // *** Fold ***
  //
  // Γ ⊢ T :: *   Γ ⊢ T ⇓ μX.U   Γ ⊢ e : [X↦μX.U]U
  // ----------------------------------------------
  // Γ ⊢ fold [T] e : T
  typeOf:
    (ctx,Fold(T,e)) ->
    (T,<conc> (msgs1,msgs2,msgs3))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <norm> (ctx,T) => T'
        ; <typeEqMu> T' => (X,T1,msgs3)
        ; <typeOf> (ctx,e) => S
        ; <typeEq> (S, <subst> (X,TyMu(X,T1),T1)) => msgs4

  // *** TApp ***
  //
  // Γ ⊢ e1 : T1   Γ ⊢ T1 ⇓ ∀X::K11.T12   Γ ⊢ T2 :: K11
  // ---------------------------------------------------
  // Γ ⊢ e1 [T2] : [X↦T2]T12
  typeOf:
    (ctx,TApp(e1,T2)) -> (<subst> (X,T2,T12),<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqForall> T1' => (X,K11,T12,msgs2)
        ; <kindOf> (ctx,T2) => (K2,msgs3)
        ; <kindEq> (K11,K2) => msgs4

  // *** App ***
  //
  // Γ ⊢ e1 : T1   Γ ⊢ e2: T2   Γ ⊢ T1 ⇓ T11 → T12   Γ ⊢ T2 ⇓ T11
  // -------------------------------------------------------------
  // Γ ⊢ e1 e2 : T12
  typeOf:
    (ctx,App(e1,e2)) -> (T12,<conc> (msgs1,msgs2,msgs3,msgs4))
    where <typeOf> (ctx,e1) => (T1,msgs1)
        ; <typeOf> (ctx,e2) => (T2,msgs2)
        ; <norm> (ctx,T1) => T1'
        ; <typeEqArrow> T1' => (T11,T12,msgs3)
        ; <norm> (ctx,T2) => T2'
        ; <typeEq> (T11,T2') => msgs4

  // *** SelectRcd ***
  //
  // Γ ⊢ e : T   Γ ⊢ T ⇓ {decls}   x:S ∈ decls
  // ------------------------------------------
  // Γ ⊢ e!x : S
  typeOf:
    (ctx,SelectRcd(e,x)) -> (S,<conc> (msgs1,msgs2,msgs3))
    where <typeOf> (ctx,e) => (T,msgs1)
        ; <norm> (ctx,T) => T'
        ; <typeEqRecord> T1 => (decls,msgs2)
        ; <labType> (x,decls) => (S,msgs3)

  // *** Primitive types ***
  typeOf: (ctx,String(str)) => (TyString,[])
  typeOf: (ctx,Nat(n)) => (TyNat,[])
  typeOf: (ctx,False()) => (TyBool,[])
  typeOf: (ctx,True()) => (TyBool,[])

  // *** Variant ***
  //
  // Γ ⊢ T :: *   Γ ⊢ e : S   Γ ⊢ S ⇓ U   Γ ⊢ T ⇓ <decls>   x:U ∈ decls
  // -------------------------------------------------------------------
  // Γ ⊢ <x=e> as T : T
  typeOf:
    (ctx,Variant(e,T)) -> (T,<conc> (msgs1,msgs2,msgs3,msgs4,msgs5,msgs6))
    where <kindOf> (ctx,T) => (K,msgs1)
        ; <kindEqStar> K => msgs2
        ; <typeOf> e => (S,msgs3)
        ; <norm> S => S'
        ; <norm> T => T'
        ; <typeEqVariant> T' => (decls,msgs4)
        ; labType(x,decls) => (U,msgs5)
        ; <typeEq> (S',U) => msgs6

  // *** Record ***
  //
  // -----------
  // Γ ⊢ {} : {}
  typeOf:
    (ctx,Record([])) -> (TyRecord([]),[])
  // Γ ⊢ e : T   x ∉ sel(flds)   Γ ⊢ {flds} : S   Γ ⊢ S ⇓ {decls}
  // -------------------------------------------------------------
  // Γ ⊢ {x=e,flds} : {x:T,decls}
  typeOf:
    (ctx,Record([Field(x,e)|flds])) ->
    (Record([Field(x,T)|decls]),<conc> (msgs1,msgs2,msgs3)
    where <typeOf> (ctx,e) => T
        ; errorUnless(<not>(elem)> (x,<sel> flds)
                     | <concat-string> ["duplicate selector",x]) => msgs1
        ; <typeOf> (ctx,Record(flds)) => (S,msgs2)
        ; <norm> (ctx,S) => S'
        ; <typeEqRecord> S' => (decls,msgs3)
    

// *** Notes ***
//
// Judgments:
// * x ∉ sel(flds)
// * x:S ∈ decls
// * qx ≠ qy
// * x ≠ y
// * Γ ⊢ e : T
// * Γ ⊢ T :: K
// * Γ ⊢ T ⇓ S
// * error(<msg>)
//
// Structural equality of types modulo α-conversion, record/variant permutation,
// and with TyUnknown equal to any type.
//
// Conditional decomposition of compound types, i.e. mu X.T, \X::K.T,
// forall X::K.T, T->S, T**...**S, {x:T,...,y:S}, <x:T,...,y:S>.
