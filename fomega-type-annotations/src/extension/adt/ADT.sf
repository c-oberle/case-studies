module extension.adt.ADT

import org.sugarj.languages.Fomega
import concretesyntax.Fomega

import extension.Declaration

import contextanalysis.rules.Syntax
import contextanalysis.rules.Desugaring
import contextanalysis.rules.Verification
import contextanalysis.TypingRelation
import contextanalysis.SignatureRelation

syntax {
	context-free syntax
	  FomegaPublic? "data" FomegaID DataParams "=" DataCons -> FomegaDef {cons("DataDef")}
	
	                            -> DataParams {cons("DataParamsNil")}
	  "(" KiDecl ")" DataParams -> DataParams {cons("DataParamsCons")}
	
	  FomegaID "::" FomegaKind -> KiDecl {cons("KiDecl")}
	
	  FomegaID FomegaID "{" FomegaTyDecls "}" -> DataCon {cons("DataCon")}
	
	  DataCon              -> DataCons {cons("DataConsEnd")}
	  DataCon "|" DataCons -> DataCons {cons("DataConsCons")}
	
	lexical syntax
	  "data" -> FomegaKeyword
	
	lexical restrictions
	  "data" -/- [a-zA-Z0-9]
	
	context-free syntax
	  "~" StrategoVar -> DataParams    {cons("Metavar")}
	  "~" StrategoVar -> DataCons      {cons("Metavar")}
	  "~" StrategoVar -> DataConParams {cons("Metavar")}
	
	  "dataparams" "|[" DataParams "]|" -> StrategoTerm {cons("ToMetaExpr")}
	               "|[" DataParams "]|" -> StrategoTerm {cons("ToMetaExpr")}
	
	  "datacons" "|[" DataCons "]|" -> StrategoTerm {cons("ToMetaExpr")}
	             "|[" DataCons "]|" -> StrategoTerm {cons("ToMetaExpr")}
}


desugaring desugar-data {
signature
  constructors
    ADT-TYPE:    FomegaID * DataParams * DataCons -> StrategoTerm
    ADT-ABS:     DataParams * FomegaType -> StrategoTerm
    ADT-OP:      FomegaID * DataParams * DataCons -> StrategoTerm 
    ADT-ARG:     DataParams -> StrategoTerm
    ADT-PK:      DataParams -> StrategoTerm
    ADT-DECLS:   DataCons -> StrategoTerm
    ADT-CK:      DataParams -> StrategoTerm
    ADT-CA:      DataParams * FomegaType * FomegaType -> StrategoTerm
    ADT-UNCURRY: FomegaID * DataParams * FomegaType -> StrategoTerm


rules
  desugar-data :
    |[ data ~%X ~params = ~dcons ~=defs ]| -> |[ type ~%X = M~ADT-TYPE(X, params, dcons) ~=defs ]|

  desugar-data :
    |[ data ~%X ~params = ~dcons ]| -> |[ type ~%X = M~ADT-TYPE(X, params, dcons) ]|

  desugar-data :
    ADT-TYPE(X, params, dcons) ->
      fomega-type |[ M~ADT-ABS(params, |[ mu (M~ADT-OP(X, params, dcons), M~(ADT-ARG(params))) ]|) ]|

  desugar-data :
    ADT-ABS(dataparams |[ ]|, T) -> fomega-type |[ ~T ]|

  desugar-data :
    ADT-ABS(|[ (~%X::~K) ~params ]|, T) -> fomega-type |[ \~%X::~K. M~ADT-ABS(params, T) ]|
    
  desugar-data :
    ADT-OP(X, params, dcons) ->
      fomega-type |[ \~%X :: M~(ADT-PK(params)) => *.
                       \args :: M~(ADT-PK(params)).
                         M~ADT-UNCURRY(X, params, |[ <M~(ADT-DECLS(dcons))> ]|)
                  ]| 

  desugar-data :
    ADT-UNCURRY(X, params, T) ->
      fomega-type |[ (\~%X :: M~(ADT-CK(params)).  M~ADT-CA(params, fomega-type |[ args ]|, ADT-ABS(params, T)))
                     M~ADT-ABS(params, fomega-type |[ ~%X M~(ADT-ARG(params)) ]|)
                  ]|


  desugar-data :
    ADT-CK(dataparams |[ ]|) -> |[ * ]|

  desugar-data :
    ADT-CK(dataparams |[ (~%X::~K) ~params ]|) -> |[ ~K => M~(ADT-CK(params)) ]|


  desugar-data :
    ADT-CA(dataparams |[ ]|, args, T) -> T

  desugar-data :
    ADT-CA(dataparams |[ (~%X::~K) ~params ]|, args, T) ->
      ADT-CA(params, fomega-type |[ ~args.2 ]|, fomega-type |[ ~T (~args.1) ]|)


  desugar-data :
    ADT-DECLS(datacons |[ ~%Xcon ~%Xdiscr { ~decls } ]|) -> 
      fomega-tydecls |[ ~%Xcon : { ~decls } ]|

  desugar-data :
    ADT-DECLS(datacons |[ ~%Xcon ~%Xdiscr { ~decls } | ~dcons ]|) ->
      fomega-tydecls |[ ~%Xcon : { ~decls } Mtydecls1~(ADT-DECLS(dcons)) ]|


  desugar-data :
    ADT-ARG(dataparams |[ ]|) -> fomega-type |[ [] ]|

  desugar-data :
    ADT-ARG(|[ (~%X::~K) ~params ]|) -> fomega-type |[ {~%X, M~(ADT-ARG(params))} ]|


  desugar-data :
    ADT-PK(dataparams |[ ]|) -> fomega-kind |[ [] ]|

  desugar-data :
    ADT-PK(|[ (~%X::~K) ~params ]|) -> fomega-kind |[ {~K, M~(ADT-PK(params))} ]|

}

typing {
  
~%X notin dom(~C)
~C |- M~ADT-TYPE(X, params2, dcons) :: ~K
(~C;~%X::~K=M~ADT-TYPE(X, params2, dcons)) |- ~=defs ==> ~sig
================================================================== S-DataCons
~C |- data ~%X ~params2 = ~dcons ~=defs ==> ~sig



~%X notin dom(~C)
~C |- M~ADT-TYPE(X, params, dcons) :: ~K
================================================================== S-DataEnd
~C |- data ~%X ~params = ~dcons ==> ()


~C |- M~ADT-ABS(params, |[ mu (M~ADT-OP(X, params, dcons), M~(ADT-ARG(params))) ]|) :: ~K
========================================================================================= ADT-TYPE
~C |- M~ADT-TYPE(X, params, dcons) :: ~K

=================================================================================== ADT-TYPE-Norm
~C |- M~ADT-TYPE(X, params, dcons) 
   ~> M~ADT-ABS(params, |[ mu (M~ADT-OP(X, params, dcons), M~(ADT-ARG(params))) ]|)



~C |- ~T :: ~K
============================================= ADT-ABSNil
~C |- M~ADT-ABS(dataparams |[ ]|, T) :: ~K 

========================================== ADT-ABSNil-Norm
~C |- M~ADT-ABS(dataparams |[ ]|, T) ~> ~T


(~C;~%X::~K1) |- M~ADT-ABS(params, T) :: ~K2
======================================================================== ADT-ABSCons
~C |- M~ADT-ABS(dataparams |[ (~%X::~K1) ~params ]|, T) :: ~K1 => ~K2

~C |- M~ADT-ABS(params, T) ~> ~T2
========================================== ADT-ABSCons-Norm
~C |- M~ADT-ABS(dataparams |[ (~%X::~K) ~params ]|, T)
   ~> \~%X::~K. ~T2



((~C; ~%X :: M~ADT-PK(params) => *); args :: M~ADT-PK(params)) |-
                                     M~ADT-UNCURRY(X, params, |[ <M~(ADT-DECLS(dcons))> ]|) :: *
================================================================================================ ADT-OP
~C |- M~ADT-OP(X, params, dcons) :: (M~ADT-PK(params) => *) => M~ADT-PK(params) => *

============================================================================================================================ ADT-OP-Norm
~C |- M~ADT-OP(X, params, dcons) 
   ~> \~%X :: M~(ADT-PK(params)) => *.  \args :: M~(ADT-PK(params)).  M~ADT-UNCURRY(X, params, |[ <M~(ADT-DECLS(dcons))> ]|)


(~C; ~%X :: M~ADT-CK(params)) |- M~ADT-CA(params, fomega-type |[ args ]|, ADT-ABS(params, T)) :: *
~C |- M~ADT-ABS(params, fomega-type |[ ~%X M~(ADT-ARG(params)) ]|) :: M~(ADT-CK(params))
======================================================================================================== ADT-UNCURRY
~C |- M~ADT-UNCURRY(X, params, T) :: *


================================================================================================= ADT-UNCURRY-Norm
~C |- M~ADT-UNCURRY(X, params, T)
   ~> (\~%X :: M~(ADT-CK(params)).  M~ADT-CA(params, fomega-type |[ args ]|, ADT-ABS(params, T)))
      M~ADT-ABS(params, fomega-type |[ ~%X M~(ADT-ARG(params)) ]|)


~C |- ~args :: []
~C |- ~T :: *
================================================= ADT-CANil
~C |- M~ADT-CA(dataparams |[ ]|, args, T) :: *

=============================================== ADT-CANil-Norm
~C |- M~ADT-CA(dataparams |[ ]|, args, T) ~> ~T

//~C |- ~args :: {~K, M~ADT-PK(params)}
//~C |- ~T :: ~K => M~ADT-CK(params)
~C |- M~ADT-CA(params, fomega-type |[ ~args.2 ]|, fomega-type |[ ~T (~args.1) ]|) :: *
=================================================================== ADT-CACons
~C |- M~ADT-CA(dataparams |[ (~%X::~K) ~params ]|, args, T) :: *


================================================================================= ADT-CACons-Norm
~C |- M~ADT-CA(dataparams |[ (~%X::~K) ~params ]|, args, T)
   ~> M~ADT-CA(params, fomega-type |[ ~args.2 ]|, fomega-type |[ ~T (~args.1) ]|)


~C |- { ~decls } :: *
======================================================================== ADT-DECLSEnd
~C |- <M~ADT-DECLS(datacons |[ ~%Xcon ~%Xdiscr { ~decls } ]|)> :: *

~C |- <M~(ADT-DECLS(dcons))> :: *
~C |- { ~decls } :: *
~%Xcon notin lab(M~(ADT-DECLS(dcons)))
================================================================================= ADT-DECLSCons
~C |- <M~ADT-DECLS(datacons |[ ~%Xcon ~%Xdiscr { ~decls } | ~dcons ]|)> :: *


========================================== ADT-ARGNil
~C |- M~ADT-ARG(dataparams |[ ]|) :: M~ADT-PK(dataparams |[ ]|)

~C |- ~%X :: ~K
~C |- M~(ADT-ARG(params)) :: M~(ADT-PK(params))
======================================================================================== ADT-ARGCons
~C |- M~ADT-ARG(dataparams |[ (~%X::~K) ~params ]|) :: {~K, M~(ADT-PK(params))}



=================================== ADT-PKNil
M~ADT-PK(dataparams |[ ]|) =::=> []

M~ADT-PK(params) =::=> ~K2
================================================= ADT-PKCons
M~ADT-PK(|[ (~%X::~K) ~params ]|) =::=> {~K, ~K2}
 
================================== ADT-CKNil
M~ADT-CK(dataparams |[ ]|) =::=> *

M~ADT-CK(params) =::=> ~K2
============================================================= ADT-PKCons
M~ADT-CK(dataparams |[ (~%X::~K) ~params ]|)  =::=> ~K => ~K2


~%Xcon != ~%Xcon2
========================================================================== ADT-DECLSEnd-Lab
~%Xcon notin lab(M~(ADT-DECLS(datacons |[ ~%Xcon2 ~%Xdiscr { ~decls } ]|)))

~%Xcon != ~%Xcon2
~%Xcon notin lab(M~(ADT-DECLS(dcons)))
==================================================================================== ADT-DECLSCons-Lab
~%Xcon notin lab(M~(ADT-DECLS(datacons |[ ~%Xcon2 ~%Xdiscr { ~decls } | ~dcons ]|)))


}

