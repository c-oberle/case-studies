module contextanalysis.KindChecker

import contextanalysis.rules.Syntax
import contextanalysis.rules.Desugaring


============== K-Nat
~C |- Nat :: *


================= K-String
~C |- String :: *


=============== K-Bool
~C |- Bool :: *


~%X :: ~K in ~C
=============== K-TVar
~C |- ~%X :: ~K


~C |- ~T1 :: (~K => *) => ~K => *
~C |- ~T2 :: ~K
================================= K-Mu
~C |- mu ~K. (~T1, ~T2) :: *


~C |- ~T1 :: *
~C |- ~T2 :: *
===================== K-Arrow
~C |- ~T1 -> ~T2 :: *


(~C;~%X::~K1) |- ~T2 :: *
=============================== K-Forall
~C |- forall ~%X::~K1. ~T2 :: *


(~C;~%X::~K1) |- ~T2 :: ~K2
================================== K-Abs
~C |- \~%X::~K1. ~T2 :: ~K1 => ~K2 


~C |- ~T1 :: ~K11 => ~K12
~C |- ~T2 :: ~K11
========================= K-App
~C |- ~T1 ~T2 :: ~K12


~C |- ~T :: *
=================== K-VariantEnd
~C |- <~%x:~T> :: *


~C |- ~T :: *
~%x notin lab(~decls)
~C |- <~decls> :: *
=========================== K-VariantCons
~C |- <~%x:~T ~:decls> :: *


============= K-RecordNil
~C |- {} :: *


~C |- ~T :: *
~%x notin lab(~decls)
~C |- {~decls} :: *
=========================== K-RecordCons
~C |- {~%x:~T ~:decls} :: *



~C |- ~T1 :: ~K1
~C |- ~T2 :: ~K2
============================== K-Pair
~C |- {~T1, ~T2} :: {~K1, ~K2}


~C |- ~T :: {~K1, ~K2}
====================== K-Fst
~C |- ~T.1 :: ~K1


~C |- ~T :: {~K1, ~K2}
====================== K-Snd
~C |- ~T.2 :: ~K2


============== K-Empty
~C |- [] :: []

// import org.sugarj.languages.Fomega
// 
// import contextanalysis.Annotations
// import contextanalysis.Contexts
// import contextanalysis.KindOperations
// import contextanalysis.TypeOperations
// 
// 
// rules
// 
//   annotate-kind =
//       ?(C, node@TyMu(K, T1, T2))
//     ; <annotate-kind> (C, T1)
//     ; <get-kind> T1 => K1
//     ; <kind-eq-arrow> K1 => (K11, K12, msgs1)
//     ; <kind-eq-arrow> K11 => (K111, K112, msgs2)
//     ; <kind-eq-star> K112 => msgs3
//     ; <kind-eq-arrow> K12 => (K121, K122, msgs4)
//     ; <kind-eq-star> K122 => msgs5
//     ; <kind-eq> (K111, K121) => msgs6
//     ; <annotate-kind> (C, T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq> (K2, K111) => msgs7
//     ; <add-context-errors> (<conc> (msgs1, msgs2, msgs3, msgs4, msgs5, msgs6, msgs7), node)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyArrow(T1, T2))
//     ; <annotate-kind> (C, T1)
//     ; <get-kind> T1 => K1
//     ; <kind-eq-star> K1 => msgs1
//     ; <add-context-errors> (msgs1, node)
//     ; <annotate-kind> (C, T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq-star> K2 => msgs2
//     ; <add-context-errors> (msgs2, node)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyForall(X, K1, T2))
//     ; <annotate-kind> (CtxBindTVar(C, X, K1), T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq-star> K2 => msgs2
//     ; <add-context-errors> (msgs2, node)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyAbs(X, K1, T2))
//     ; <annotate-kind> (CtxBindTVar(C, X, K1), T2)
//     ; <get-kind> T2 => K2
//     ; <put-kind> (KiArrow(K1, K2), node)
// 
//   annotate-kind =
//       ?(C, node@TyApp(T1, T2))
//     ; <annotate-kind> (C, T1)
//     ; <get-kind> T1 => K1
//     ; <annotate-kind> (C, T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq-arrow> K1 => (K11, K12, msgs1)
//     ; <kind-eq> (K11, K2) => msgs2
//     ; <put-kind> (K12, node)
//     ; <add-context-errors> (msgs1, node)
//     ; <add-context-errors> (msgs2, node)
// 
//   annotate-kind =
//       ?(C, node@TyVariant(decls))
//     ; <check-decls> (C, decls)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyRecord(decls))
//     ; <check-decls> (C, decls)
//     ; <put-kind> (KiStar(), node)
// 
// 
// rules
// 
//   check-decls =
//       ?(C, node@TyDeclsNil())
// 
//   check-decls =
//       ?(C, node@TyDeclsCons(TyDecl(x, T), decls))
//     ; if <elem(structurally-equal)> (x, <lab> decls) then
//         <add-context-errors> ([<concat-strings> ["duplicate label ", x]], node)
//       else
//         id
//       end
//     ; <annotate-kind> (C, T)
//     ; <get-kind> T => K
//     ; <kind-eq-star> K => msgs
//     ; <add-context-errors> (msgs, node)
//     ; <check-decls> (C, decls)
