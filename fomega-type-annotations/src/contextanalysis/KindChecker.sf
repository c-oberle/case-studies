module contextanalysis.KindChecker

import contextanalysis.rules.Syntax
import contextanalysis.rules.Desugaring


============== K-Nat
~C |- Nat :: *


================= K-String
~C |- String :: *


=============== K-Bool
~C |- Bool :: *


~%X :: ~K in ~C
=============== K-TVar
~C |- ~%X :: ~K

~C |- ~T1 :: (~K => *) => ~K => *
~C |- ~T2 :: ~K
================================= K-Mu
~C |- mu ~K. (~T1, ~T2) :: *

// import org.sugarj.languages.Fomega
// 
// import contextanalysis.Annotations
// import contextanalysis.Contexts
// import contextanalysis.KindOperations
// import contextanalysis.TypeOperations
// 
// 
// rules
// 
//   annotate-kind =
//       ?(C, node@TyMu(K, T1, T2))
//     ; <annotate-kind> (C, T1)
//     ; <get-kind> T1 => K1
//     ; <kind-eq-arrow> K1 => (K11, K12, msgs1)
//     ; <kind-eq-arrow> K11 => (K111, K112, msgs2)
//     ; <kind-eq-star> K112 => msgs3
//     ; <kind-eq-arrow> K12 => (K121, K122, msgs4)
//     ; <kind-eq-star> K122 => msgs5
//     ; <kind-eq> (K111, K121) => msgs6
//     ; <annotate-kind> (C, T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq> (K2, K111) => msgs7
//     ; <add-context-errors> (<conc> (msgs1, msgs2, msgs3, msgs4, msgs5, msgs6, msgs7), node)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyArrow(T1, T2))
//     ; <annotate-kind> (C, T1)
//     ; <get-kind> T1 => K1
//     ; <kind-eq-star> K1 => msgs1
//     ; <add-context-errors> (msgs1, node)
//     ; <annotate-kind> (C, T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq-star> K2 => msgs2
//     ; <add-context-errors> (msgs2, node)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyForall(X, K1, T2))
//     ; <annotate-kind> (CtxBindTVar(C, X, K1), T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq-star> K2 => msgs2
//     ; <add-context-errors> (msgs2, node)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyAbs(X, K1, T2))
//     ; <annotate-kind> (CtxBindTVar(C, X, K1), T2)
//     ; <get-kind> T2 => K2
//     ; <put-kind> (KiArrow(K1, K2), node)
// 
//   annotate-kind =
//       ?(C, node@TyApp(T1, T2))
//     ; <annotate-kind> (C, T1)
//     ; <get-kind> T1 => K1
//     ; <annotate-kind> (C, T2)
//     ; <get-kind> T2 => K2
//     ; <kind-eq-arrow> K1 => (K11, K12, msgs1)
//     ; <kind-eq> (K11, K2) => msgs2
//     ; <put-kind> (K12, node)
//     ; <add-context-errors> (msgs1, node)
//     ; <add-context-errors> (msgs2, node)
// 
//   annotate-kind =
//       ?(C, node@TyVariant(decls))
//     ; <check-decls> (C, decls)
//     ; <put-kind> (KiStar(), node)
// 
//   annotate-kind =
//       ?(C, node@TyRecord(decls))
//     ; <check-decls> (C, decls)
//     ; <put-kind> (KiStar(), node)
// 
// 
// rules
// 
//   check-decls =
//       ?(C, node@TyDeclsNil())
// 
//   check-decls =
//       ?(C, node@TyDeclsCons(TyDecl(x, T), decls))
//     ; if <elem(structurally-equal)> (x, <lab> decls) then
//         <add-context-errors> ([<concat-strings> ["duplicate label ", x]], node)
//       else
//         id
//       end
//     ; <annotate-kind> (C, T)
//     ; <get-kind> T => K
//     ; <kind-eq-star> K => msgs
//     ; <add-context-errors> (msgs, node)
//     ; <check-decls> (C, decls)
