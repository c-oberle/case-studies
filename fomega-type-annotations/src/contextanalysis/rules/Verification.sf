module contextanalysis.rules.Verification

import contextanalysis.rules.Syntax
import contextanalysis.rules.Desugaring // for premises-to-list

import extension.TypeOf

// import extension.Declaration

rules // TODO: these two definitions belong to Analyze.str

  reinit-for-analysis = bottomup(reinit-analysis-data-annotation)

  reinit-analysis-data-annotation =
    ?node;
    <get-annotations; filter(not(?("analysis-data", _)))> node => annos;
    <get-annotations; filter(?("analysis-data", _))> node => ana-annos;
    if !ana-annos; ?[] then ![("analysis-data", <new-hashtable>)] else !ana-annos end => new-ana-annos;
    <set-annotations> (node, <conc> (annos, new-ana-annos))


rules

  constraint-error = verify-context-rule


rules

  desugar-extension-internal = fail

  verify-context-rule :
    TypingRule(premises, RuleName(sep, Some(Var(name))), TypingJudgment(C, e, T)) ->
      result
    where // TODO: only allow desugar-extension-internal; extension declaration 
          //       requires this rule to be successfully applicable to subject
          <debug(!"*** Verify type rule ")> name
        ; if <desugar-extension-internal; reinit-for-analysis> e => e-desugared then
              <strip-annos; debug(<concat-strings> ["Original conclusion term  (", name, "): "])> e
            ; <strip-annos; debug(<concat-strings> ["Desugared conclusion term (", name, "): "])> e-desugared
            ; <premises-to-list> premises => premises-list
            ; {| Dynamic-Annotate-Type, Dynamic-Annotate-Kind, Dynamic-Par-Reduce-Type, Dynamic-Lookup-Expr-Var:
                   <activate-dynamic-axioms> premises-list
                 ; <resolve-typeof(|C); reinit-for-analysis> e-desugared => e-resolved
                 ; <strip-annos; debug(<concat-strings> ["Resolved conclusion term  (", name, "): "])> e-resolved 
                 ; <annotate-type> (C, e-resolved)
                 ; <collect-all-context-errors> e-resolved => errs
                 ; <get-type> e-resolved => U
                 ; if !errs; ?[] then
                       <norm> (C, T) => T'
                     ; <norm> (C, U) => U'
                   else
                     !T; ?T'; !U; ?U'
                   end
              |}
            ; <strip-annos; debug(!"Expected type: ")> T'
            ; <strip-annos; debug(!"Actual type:   ")> U'
            ; <debug(!"Type errors:   ")> errs
            ; if !errs; ?[] then
                  <type-eq> (T', U') => msgs
                ; if !msgs; ?[] then
                    debug(!(<concat-strings> ["Successfully verified typing rule ", name, "."])); fail
                  else
                    ![( name
                     , <concat-strings> [ "Could not verify typing rule ", name, ".\n"
                                        , "Expected type: ", <write-to-string> T', ".\n"
                                        , "But got type:  ", <write-to-string> U', "."])]
                  end
              else
                ![( name
                  , <concat-strings> [ "Could not verify typing rule ", name, ".\n"
                                     , "The type checker returned the following errors:\n"
                                     , <write-to-string> errs])]
              end
          else
              <debug(!"Could not desugar the conclusion of rule ")> name
            ; <strip-annos; debug(!"  ")> e 
            ; ![( name, <concat-strings> [ "Could not desugar the conclusion of typing rule ", name, ":\n"
                                         , <strip-annos; write-to-string> e])]
          end => result

  resolve-typeof(|C) = bottomup(resolve-typeof1(|C) <+ id)

  resolve-typeof1(|C) :
    TypeOf(e) -> R
    where <annotate-type> (C, e)
        ; <get-type> e => R
        ; <strip-annos> R => R-stripped
        ; rules(
            Dynamic-Annotate-Kind :+
              arg -> res
              where <strip-annos> arg => (C-any, R-stripped)
                  ; !arg => (C-arg, T-arg)
                  ; <put-kind> (KiStar(), T-arg) => res
          )

  resolve-typeof1(|C) :
    TypeOfAs(T, e, S) -> U
    where <annotate-type> (C, e)
        ; <get-type> e => R
        ; <norm> (C, R) => R'
        ; <norm> (C, S) => S'
        ; <unify-types> (S', R') => sub
        ; <apply-subst> (sub, T) => U
        ; <strip-annos> U => U-stripped
        ; rules(
            Dynamic-Annotate-Kind :+
              arg -> res
              where <strip-annos> arg => (C-any, U-stripped)
                  ; !arg => (C-arg, T-arg)
                  ; <put-kind> (KiStar(), T-arg) => res
          )
          // Since we only annotate types of kind `*' we may add this dynamic rule.
          // This invariant must not be violated by typing rules of extensions.

  verify-context-rule :
    KindingRule(premises, RuleName(sep, Some(Var(name))), judge@KindingJudgment(C, T, K)) ->
      result
    where <debug(!"*** Verify kind rule ")> (name, <strip-annos> judge)
        ; if <desugar-extension-internal; reinit-for-analysis> T => T-desugared then
              <strip-annos; debug(<concat-strings> ["Original conclusion type  (", name, "): "])> T
            ; <strip-annos; debug(<concat-strings> ["Desugared conclusion type (", name, "): "])> T-desugared
            ; <premises-to-list> premises => premises-list
            ; {| Dynamic-Annotate-Kind, Dynamic-Lookup-Type-Var:
                   <activate-dynamic-axioms> premises-list
                 ; <annotate-kind> (C, T-desugared)
                 ; <collect-all-context-errors> T-desugared => errs
                 ; <get-kind> T-desugared => J
              |}
            ; <strip-annos; debug(!"Expected kind: ")> K
            ; <strip-annos; debug(!"Actual kind:   ")> J
            ; <debug(!"Kind errors:   ")> errs
            ; if !errs; ?[] then
                  <kind-eq> (K, J) => msgs
                ; if !msgs; ?[] then
                    debug(!(<concat-strings> ["Successfully verified kinding rule ", name, "."])); fail
                  else
                    ![( name
                     , <concat-strings> [ "Could not verify kinding rule ", name, ".\n"
                                        , "Expected kind: ", <write-to-string> K, ".\n"
                                        , "But got kind:  ", <write-to-string> J, "."])]
                  end
              else
                ![( name
                  , <concat-strings> [ "Could not verify kinding rule ", name, ".\n"
                                     , "The kind checker returned the following errors:\n"
                                     , <write-to-string> errs])]
              end
          else
              <debug(!"Could not desugar the conclusion of rule ")> name
            ; <strip-annos; debug(!"  ")> T
            ; ![( name, <concat-strings> [ "Could not desugar the conclusion of kinding rule ", name, ":"
                                         , <strip-annos; write-to-string> T])]
          end => result

  verify-context-rule :
    SignatureRule(premises, RuleName(sep, Some(Var(name))), judge@SignatureJudgment(C, Defs, Sig)) ->
      result
    where <debug-analysis(!"*** Verify signature rule ")> (name, judge)
        ; if <desugar-extension-internal; reinit-for-analysis> Defs => Defs-desugared then
              <strip-annos; debug(<concat-strings> ["Original conclusion defs  (", name, "): "])> Defs
            ; <strip-annos; debug(<concat-strings> ["Desugared conclusion defs (", name, "): "])> Defs-desugared
            ; <premises-to-list> premises => premises-list
            ; {| Dynamic-Annotate-Type, Dynamic-Annotate-Kind, Dynamic-Par-Reduce-Type, Dynamic-Lookup-Expr-Var, Dynamic-Annotate-Signature:
                   <activate-dynamic-axioms> premises-list
                 ; <annotate-signature> (C, Defs-desugared)
                 ; <collect-all-context-errors> Defs-desugared => errs
                 ; <get-signature> Defs-desugared => Sig2
              |}
            ; <strip-annos; debug(!"Expected signature: ")> Sig
            ; <strip-annos; debug(!"Actual signature:   ")> Sig2
            ; <debug(!"Signature errors:   ")> errs
            ; if !errs; ?[] then
                  <structurally-equal> (Sig, Sig2) => msgs
                ; if !msgs; ?[] then
                    debug(!(<concat-strings> ["Successfully verified signature rule ", name, "."])); fail
                  else
                    ![( name
                     , <concat-strings> [ "Could not verify signature rule ", name, ".\n"
                                        , "Expected signature: ", <write-to-string> Sig, ".\n"
                                        , "But got signature:  ", <write-to-string> Sig2, "."])]
                  end
              else
                ![( name
                  , <concat-strings> [ "Could not verify signature rule ", name, ".\n"
                                     , "The signature checker returned the following errors:\n"
                                     , <write-to-string> errs])]
              end
          else
              <debug(!"Could not desugar the conclusion of rule ")> name
            ; <strip-annos; debug(!"  ")> Defs
            ; ![( name, <concat-strings> [ "Could not desugar the conclusion of signature rule ", name, ":"
                                         , <strip-annos; write-to-string> Defs])]
          end => result

rules // Activate dynamic axioms in the order of appearance in the typing rule

  activate-dynamic-axioms :
    [] -> []

  activate-dynamic-axioms :
    [judgment|judgments] ->
      <activate-dynamic-axioms> judgments
      where <activate-dynamic-axiom> judgment

  activate-dynamic-axiom =
      ?TypingJudgment(C, e, T)
    ; <strip-annos> (C, e, T) => (C-stripped, e-stripped, T-stripped)
    // ; <norm-context; strip-annos> C => C-stripped
    ; rules(
        Dynamic-Annotate-Type-Defined :+
          arg -> res
          where <strip-annos> arg => (C-stripped, e-stripped)
              // ; <norm-context; strip-annos> C-any => C-stripped
              ; !arg => (C-arg, e-arg)
              ; <put-type> (T, e-arg) => res
      )
    // ; rules(
    //     Dynamic-Par-Reduce-Type :+
    //       arg -> res
    //       where <strip-annos> arg => (C-any, TypeOf(e-stripped))
    //           ; !T => res
    //   )
    // ; rules(
    //     Dynamic-Annotate-Kind :+
    //       arg -> res
    //       where <strip-annos> arg => (C-stripped, TypeOf(e-stripped))
    //           ; !arg => (C-arg, T-arg)
    //           ; <put-kind> (KiStar(), T-arg) => res
    //   )
    // ; <debug(!"Activated TJ ")> (C-stripped, e-stripped, T-stripped)

  activate-dynamic-axiom =
      ?KindingJudgment(C, T, K)
    ; <strip-annos> (C, T, K) => (C-stripped, T-stripped, K-stripped)
    // ; <norm-context; strip-annos> C => C-stripped
    ; rules(
        Dynamic-Annotate-Kind :+
          arg -> res
          where <strip-annos> arg => (C-stripped, T-stripped)
              // ; <norm-context; strip-annos> C-any => C-stripped
              ; !arg => (C-arg, T-arg)
              ; <put-kind> (K, T-arg) => res
      )
    // ; <debug(!"Activated KJ ")> (C-stripped, T-stripped, K-stripped)

  activate-dynamic-axiom =
      ?NormalizationJudgment(C, T, T')
    ; <strip-annos> (C, T, T') => (C-stripped, T-stripped, T-stripped')
    // ; <norm-context; strip-annos> C => C-stripped
    ; rules(
        Dynamic-Par-Reduce-Type :+
          arg -> res
          where <strip-annos> arg => (C-stripped, T-stripped)
              //; <norm-context; strip-annos> C-any => C-stripped
              ; !T' => res
    )
    // ; <debug(!"Activated PJ ")> (C-stripped, T-stripped, T-stripped')

  activate-dynamic-axiom =
      ?VarInContextJudgment(x, T, C)
    ; <strip-annos> (x, T, C) => (x-stripped, T-stripped, C-stripped)
    ; rules(Dynamic-Lookup-Expr-Var : (x-stripped, C-stripped) -> (T, []))
    // ; <debug(!"Activated VJ ")> (x-stripped, T-stripped, C-stripped)

  activate-dynamic-axiom =
      ?QVarInContextJudgment(qx, T, C)
    ; <strip-annos> (qx, T, C) => (qx-stripped, T-stripped, C-stripped)
    ; rules(Dynamic-Lookup-Expr-Var : (qx-stripped, C-stripped) -> (T, []))
    // ; <debug(!"Activated VQJ ")> (qx-stripped, T-stripped, C-stripped)

  activate-dynamic-axiom =
      ?SignatureJudgment(C, Defs, Sig)
    ; <strip-annos> (Defs, Sig) => (Defs-stripped, Sig-stripped)
    ; <norm-context; strip-annos> C => C-stripped
    ; rules(
        Dynamic-Annotate-Signature :+
          arg -> res
          where <strip-annos> arg => (C-any, Defs-stripped)
              ; <norm-context; strip-annos> C-any => C-stripped
              ; !arg => (C-arg, Defs-arg)
              ; <put-signature> (Sig, Defs-arg) => res
      )

  activate-dynamic-axiom =
      ?NotinDomJudgment(x, C)
    ; <strip-annos> (x, C) => (x-stripped, C-stripped)
    ; rules(Dynamic-Not-In-Dom :+ t@(x-stripped, C-stripped) -> t)
    // ; <debug(!"Activated VQJ ")> (qx-stripped, T-stripped, C-stripped)
      
   activate-dynamic-axiom = debug-analysis(!"failed to activate dynamic axiom: "); fail


rules // norm-context

  norm-context :
    CtxEmpty() -> CtxEmpty()

  norm-context :
    CtxBindVar(C, x, T) -> CtxBindVar(C', x, T')
    where <norm-context> C => C'
        ; <norm> (C', T) => T'

  norm-context :
    CtxBindTVar(C, X, K) -> CtxBindTVar(C', X, K)
    where <norm-context> C => C'

  norm-context :
    CtxBindTVarDef(C, X, K, T) -> CtxBindTVarDef(C', X, K, T')
    where <norm-context> C => C'
        ; <norm> (C', T) => T'

  norm-context :
    Metavar(mvar) -> Metavar(mvar)


rules // Rules to hook in dynamic axioms into the judgment implementations

  annotate-type-defined = Dynamic-Annotate-Type-Defined

  par-reduce-type = Dynamic-Par-Reduce-Type

  annotate-kind = Dynamic-Annotate-Kind

  lookup-expr-var = Dynamic-Lookup-Expr-Var

  annotate-signature = Dynamic-Annotate-Signature
  
  not-in-dom = Dynamic-Not-In-Dom
