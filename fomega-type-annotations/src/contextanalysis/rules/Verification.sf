module contextanalysis.rules.Verification

import contextanalysis.rules.Syntax
import contextanalysis.rules.Desugaring // for premises-to-list

import extension.TypeOf


rules // TODO: these two definitions belong to Analyze.str

  reinit-for-analysis = bottomup(reinit-analysis-data-annotation)

  reinit-analysis-data-annotation =
    ?node;
    <get-annotations; filter(not(?("analysis-data", _)))> node => annos;
    <get-annotations; filter(?("analysis-data", _))> node => ana-annos;
    if !ana-annos; ?[] then ![("analysis-data", <new-hashtable>)] else !ana-annos end => new-ana-annos;
    <set-annotations> (node, <conc> (annos, new-ana-annos))

  write-to-string-analysis = nice-analysis-data-term; write-to-string

rules

  constraint-error = verify-context-rule


rules

  desugar-extension-internal = fail
  desugar-extension-term = oncetd(desugar-extension-internal)
  
  verify-context-rule =
    (?TypingRule(_,_,_) + ?KindingRule(_,_,_) + ?SignatureRule(_,_,_));
    metaexpr-implode;
    verify-context-rule-internal

  verify-context-rule-internal :
    TypingRule(premises, RuleName(sep, Some(Var(name))), TypingJudgment(C, e, T)) ->
      result
    where <debug(!"*** Verify type rule ")> name
        ; <debug-analysis(<concat-strings> ["Original conclusion term  (", name, "): "])> e
        ; if <desugar-extension-term; reinit-for-analysis> e => e-desugared then
              <debug-analysis(<concat-strings> ["Desugared conclusion term (", name, "): "])> e-desugared
            ; <premises-to-list> premises => premises-list
            ; {| Dynamic-Annotate-Type, Dynamic-Annotate-Kind, Dynamic-Par-Reduce-Type, Dynamic-Lookup-Expr-Var:
                   <activate-dynamic-axioms> premises-list
                 ; <resolve-all-typeofs(|C); reinit-for-analysis> e-desugared => e-resolved
                 ; <strip-annos; debug(<concat-strings> ["Resolved conclusion term  (", name, "): "])> e-resolved 
                 ; <annotate-type> (C, e-resolved)
                 ; <collect-all-context-errors> e-resolved => errs
                 ; <get-type> e-resolved => U
                 ; if !errs; ?[] then
                       <norm> (C, T) => T'
                     ; <norm> (C, U) => U'
                   else
                     !T; ?T'; !U; ?U'
                   end
              |}
            ; <strip-annos; debug(!"Expected type: ")> T'
            ; <strip-annos; debug(!"Actual type:   ")> U'
            ; <debug(!"Type errors:   ")> errs
            ; if !errs; ?[] then
                  <type-eq> (T', U') => msgs
                ; if !msgs; ?[] then
                    debug(!(<concat-strings> ["Successfully verified typing rule ", name, "."])); fail
                  else
                    ![( name
                     , <concat-strings> [ "Could not verify typing rule ", name, ".\n"
                                        , "Expected type: ", <write-to-string-analysis> T', ".\n"
                                        , "But got type:  ", <write-to-string-analysis> U', "."])]
                  end
              else
                ![( name
                  , <concat-strings> [ "Could not verify typing rule ", name, ".\n"
                                     , "The type checker returned the following errors:\n"
                                     , <write-to-string-analysis> errs])]
              end
          else
              <debug(!"Could not desugar the conclusion of rule ")> name
            ; <strip-annos; debug(!"  ")> e 
            ; ![( e, <concat-strings> [ "Could not desugar the conclusion of typing rule ", name, ":\n"
                                      , <write-to-string-analysis> e])]
          end => result

  verify-context-rule-internal :
    KindingRule(premises, RuleName(sep, Some(Var(name))), judge@KindingJudgment(C, T, K)) ->
      result
    where <debug(!"*** Verify kind rule ")> (name, <strip-annos> judge)
        ; <debug-analysis(<concat-strings> ["Original conclusion type  (", name, "): "])> T
        ; if <desugar-extension-term; reinit-for-analysis> T => T-desugared then
              <debug-analysis(<concat-strings> ["Desugared conclusion type (", name, "): "])> T-desugared
            ; <premises-to-list> premises => premises-list
            ; {| Dynamic-Annotate-Kind, Dynamic-Lookup-Type-Var:
                   <activate-dynamic-axioms> premises-list
                 ; <annotate-kind> (C, T-desugared)
                 ; <collect-all-context-errors> T-desugared => errs
                 ; <get-kind> T-desugared => J
              |}
            ; <strip-annos; debug(!"Expected kind: ")> K
            ; <strip-annos; debug(!"Actual kind:   ")> J
            ; <debug(!"Kind errors:   ")> errs
            ; if !errs; ?[] then
                  <kind-eq> (K, J) => msgs
                ; if !msgs; ?[] then
                    debug(!(<concat-strings> ["Successfully verified kinding rule ", name, "."])); fail
                  else
                    ![( name
                     , <concat-strings> [ "Could not verify kinding rule ", name, ".\n"
                                        , "Expected kind: ", <write-to-string-analysis> K, ".\n"
                                        , "But got kind:  ", <write-to-string-analysis> J, "."])]
                  end
              else
                ![( name
                  , <concat-strings> [ "Could not verify kinding rule ", name, ".\n"
                                     , "The kind checker returned the following errors:\n"
                                     , <write-to-string-analysis> errs])]
              end
          else
              <debug(!"Could not desugar the conclusion of rule ")> name
            ; <strip-annos; debug(!"  ")> T
            ; ![( T, <concat-strings> [ "Could not desugar the conclusion of kinding rule ", name, ":"
                                      , <write-to-string-analysis> T])]
          end => result

  verify-context-rule-internal :
    SignatureRule(premises, RuleName(sep, Some(Var(name))), judge@SignatureJudgment(C, Defs, Sig)) ->
      result
    where <debug-analysis(!"*** Verify signature rule ")> (name, judge)
        ; <debug-analysis(<concat-strings> ["Original conclusion defs  (", name, "): "])> Defs
        ; if <desugar-extension-term; reinit-for-analysis> Defs => Defs-desugared then
              <debug-analysis(<concat-strings> ["Desugared conclusion defs (", name, "): "])> Defs-desugared
            ; <premises-to-list> premises => premises-list
            ; {| Dynamic-Annotate-Type, Dynamic-Annotate-Kind, Dynamic-Par-Reduce-Type, Dynamic-Lookup-Expr-Var, Dynamic-Annotate-Signature:
                   <activate-dynamic-axioms> premises-list
                 ; <annotate-signature> (C, Defs-desugared)
                 ; <collect-all-context-errors> Defs-desugared => errs
                 ; <get-signature> Defs-desugared => Sig2
              |}
            ; <strip-annos; debug(!"Expected signature: ")> Sig
            ; <strip-annos; debug(!"Actual signature:   ")> Sig2
            ; <debug(!"Signature errors:   ")> errs
            ; if !errs; ?[] then
                  if <structurally-equal> (Sig, Sig2) then
                    debug(!(<concat-strings> ["Successfully verified signature rule ", name, "."])); fail
                  else
                    ![( name
                     , <concat-strings> [ "Could not verify signature rule ", name, ".\n"
                                        , "Expected signature: ", <write-to-string-analysis> Sig, ".\n"
                                        , "But got signature:  ", <write-to-string-analysis> Sig2, "."])]
                  end
              else
                ![( name
                  , <concat-strings> [ "Could not verify signature rule ", name, ".\n"
                                     , "The signature checker returned the following errors:\n"
                                     , <write-to-string-analysis> errs])]
              end
          else
              <debug(!"Could not desugar the conclusion of rule ")> name
            ; <strip-annos; debug(!"  ")> Defs
            ; ![( Defs, <concat-strings> [ "Could not desugar the conclusion of signature rule ", name, ":"
                                         , <write-to-string-analysis> Defs])]
          end => result


rules // Resolve TypeOf(As) in desugared subjects

  resolve-all-typeofs(|C) = bottomup(resolve-typeof(|C) <+ id)

  resolve-typeof(|C) :
    TypeOf(e) -> R
    where <annotate-type> (C, e)
        ; <get-type> e => R
        ; <strip-annos> R => R-stripped
        ; rules(
            Dynamic-Annotate-Kind :+
              arg -> res
              where <strip-annos> arg => (C-any, R-stripped)
                  ; !arg => (C-arg, T-arg)
                  ; <put-kind> (KiStar(), T-arg) => res
          )

  resolve-typeof(|C) :
    TypeOfAs(T, e, S) -> U
    where <annotate-type> (C, e)
        ; <get-type> e => R
        ; <norm> (C, R) => R'
        ; <norm> (C, S) => S'
        ; <unify-types> (S', R') => sub
        ; <apply-subst> (sub, T) => U
        ; <strip-annos> U => U-stripped
        ; rules(
            Dynamic-Annotate-Kind :+
              arg -> res
              where <strip-annos> arg => (C-any, U-stripped)
                  ; !arg => (C-arg, T-arg)
                  ; <put-kind> (KiStar(), T-arg) => res
          )
          // Since we only annotate types of kind `*' we may add this dynamic rule.
          // This invariant must not be violated by typing rules of extensions.


rules // Activate dynamic axioms in the order of appearance in the typing rule

  activate-dynamic-axioms :
    [] -> []

  activate-dynamic-axioms :
    [judgment|judgments] ->
      <activate-dynamic-axioms> judgments
      where <activate-dynamic-axiom> judgment

  activate-dynamic-axiom =
      ?TypingJudgment(C, e, T)
    ; <strip-annos> (C, e, T) => (C-stripped, e-stripped, T-stripped)
    ; rules(
        Dynamic-Annotate-Type-Defined :+
          arg -> res
          where <strip-annos> arg => (C-stripped, e-stripped)
              ; !arg => (C-arg, e-arg)
              ; <put-type> (T, e-arg) => res
      )

  activate-dynamic-axiom =
      ?KindingJudgment(C, T, K)
    ; <strip-annos;debug-analysis(!"dyn kinding rule: ")> (C, T, K) => (C-stripped, T-stripped, K-stripped)
    ; rules(
        Dynamic-Annotate-Kind :+
          arg -> res
          where <strip-annos; debug-analysis(!"dyn kind was: "); where(!(C-stripped,T-stripped); debug-analysis(!"dyn kind exp: "))> arg => (C-any, T-stripped)
              ; <norm-context; strip-annos> C-any => C-stripped
              ; !arg => (C-arg, T-arg)
              ; <put-kind> (K, T-arg) => res
      )
    // ; <debug(!"Activated kinding judgment ")> (C-stripped, T-stripped, K-stripped)

  activate-dynamic-axiom =
      ?NormalizationJudgment(C, T, T')
    ; <strip-annos> (C, T, T') => (C-stripped, T-stripped, T-stripped')
    ; rules(
        Dynamic-Par-Reduce-Type :+
          arg -> res
          where <strip-annos> arg => (C-stripped, T-stripped)
              ; !T' => res
    )
    //; <debug(!"Activated parallel reduction judgment ")> (C-stripped, T-stripped, T-stripped')

  activate-dynamic-axiom =
      ?VarInContextJudgment(x, T, C)
    ; <strip-annos> (x, T, C) => (x-stripped, T-stripped, C-stripped)
    ; rules(Dynamic-Lookup-Expr-Var : (x-stripped, C-stripped) -> (T, []))
    // ; <debug(!"Activated variable lookup ")> (x-stripped, T-stripped, C-stripped)

  activate-dynamic-axiom =
      ?QVarInContextJudgment(qx, T, C)
    ; <strip-annos> (qx, T, C) => (qx-stripped, T-stripped, C-stripped)
    ; rules(Dynamic-Lookup-Expr-Var : (qx-stripped, C-stripped) -> (T, []))
    // ; <debug(!"Activated qualified variable lookup ")> (qx-stripped, T-stripped, C-stripped)

  activate-dynamic-axiom =
      ?SignatureJudgment(C, Defs, Sig)
    ; <strip-annos> (Defs, Sig) => (Defs-stripped, Sig-stripped)
    ; <norm-context; strip-annos> C => C-stripped
    ; rules(
        Dynamic-Annotate-Signature :+
          arg -> res
          where <strip-annos> arg => (C-any, Defs-stripped)
              ; <norm-context; strip-annos> C-any => C-stripped
              ; !arg => (C-arg, Defs-arg)
              ; <put-signature> (Sig, Defs-arg) => res
      )

  activate-dynamic-axiom =
      ?NotinDomJudgment(x, C)
    ; <strip-annos> (x, C) => (x-stripped, C-stripped)
    ; rules(
        Dynamic-Not-In-Dom :+
          arg -> arg 
          where <strip-annos> arg => (x-stripped, C-stripped); <strip-annos> arg)

   activate-dynamic-axiom = debug-analysis(!"failed to activate dynamic axiom: "); fail


rules // implode MetaExpr

  metaexpr-implode =
    bottomup(try(?MetaExpr(<trm-metaexpr-implode>)))

  trm-metaexpr-implode =
    ?NoAnnoList(<pre-metaexpr-implode>)
  + strip-annos;\ Var(v) -> Metavar(Var(v)) \
  + ?ToMetaExpr(<id>)
  
  pre-metaexpr-implode =
    ?Char(<id>) + ?Int(<id>) + ?Real(<id>) + ?Str(<id>)
  + strip-annos;\ Tuple(ts) -> ""#(<map(trm-metaexpr-implode)> ts) \;try(?""#([<id>]))
  + ?List(<map(trm-metaexpr-implode)>)
  + strip-annos;\ ListTail(hs, tl) -> <conc> (<map(trm-metaexpr-implode)> hs, <trm-metaexpr-implode> tl) \
  + strip-annos;\ Op(n, args) -> n#(<map(trm-metaexpr-implode)> args) \
  + strip-annos;\ Var(v) -> Metavar(Var(v)) \


rules // norm-context

  norm-context :
    CtxEmpty() -> CtxEmpty()

  norm-context :
    CtxBindVar(C, x, T) -> CtxBindVar(C', x, T')
    where <norm-context> C => C'
        ; <norm> (C', T) => T'

  norm-context :
    CtxBindTVar(C, X, K) -> CtxBindTVar(C', X, K)
    where <norm-context> C => C'

  norm-context :
    CtxBindTVarDef(C, X, K, T) -> CtxBindTVarDef(C', X, K, T')
    where <norm-context> C => C'
        ; <norm> (C', T) => T'

  norm-context :
    Metavar(mvar) -> Metavar(mvar)


rules // Rules to hook in dynamic axioms into the judgment implementations

  annotate-type-defined = Dynamic-Annotate-Type-Defined

  par-reduce-type = Dynamic-Par-Reduce-Type

  annotate-kind-defined = Dynamic-Annotate-Kind

  lookup-expr-var = Dynamic-Lookup-Expr-Var

  annotate-signature-defined = Dynamic-Annotate-Signature

  not-in-dom = Dynamic-Not-In-Dom
