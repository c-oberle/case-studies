package quest.analysis;

public sugar Satisfiability {
  rules
    is-satisfiable =
      innermost(reduce);
      (?Lit(Bool(_))
       <+ repeat(remove-equation);
          innermost(reduce);
          repeat(remove-variable);
          innermost(reduce));
      ?Lit(Bool(True))

    remove-equation =
      ?t; oncetd({c: where(?c#([_,_]); <elem> (c, ["Lt", "Gt", "LtEq", "GtEq", "Eq", "NotEq"])); ?op});
      <bottomup({t*: try(?op{t*}; !Lit(Bool(True)))})> t => with-true;
      <bottomup({t*: try(?op{t*}; !Lit(Bool(False)))})> t => with-false;
      !LazyOr(with-true, with-false);
      is-satisfiable
    
    remove-variable =
      ?t; oncetd(ExprName(Id(?name)));
      <subst-all-vars(|name, Lit(Bool(True)))> t => with-true;
      <subst-all-vars(|name, Lit(Bool(False)))> t => with-false;
      !LazyOr(with-true, with-false);
      is-satisfiable
    
    reduce : LazyAnd(Lit(Bool(False)), _) -> Lit(Bool(False))
    reduce : LazyAnd(Lit(Bool(True)), t2) -> t2
    reduce : LazyOr(Lit(Bool(True)), _) -> Lit(Bool(True))
    reduce : LazyOr(Lit(Bool(False)), t2) -> t2
    reduce : Not(Lit(Bool(True))) -> List(Bool(False))
    reduce : Not(Lit(Bool(False))) -> List(Bool(True))
    
    subst-all-vars(|name, val) = bottomup(try(subst-var(|name, val)))
    subst-var(|name, val) = ?ExprName(Id(name)); !val
}